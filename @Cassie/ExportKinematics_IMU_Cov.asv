function ExportKinematics_IMU_Cov(obj, export_function, export_path)
% Computes the Forward Kinematics Covariance Matrix (IMU to contact)
%
%   Author: Ross Hartley
%   Date:   11/15/2017
%
% Encoder Vector
encoders = SymVariable(obj.States.x(7:end));

% Left Foot Contact Frame
joints = obj.Joints(7:13);
joint_frames = cell(1,length(joints));
for i = 1:length(joints)
    joint_frames{i} = CoordinateFrame(...
        'Name',joints(i).Name,...
        'Reference',joints(i),...
        'Offset',[0, 0, 0],...
        'R',[0, 0, 0]);
end

frames = {obj.OtherPoints.VectorNav, joint_frames{:}, obj.ContactPoints.LeftToeBottom};
[Sigma_I1L, Q_I1L, S_I1L] = Compute_FK_Covariance(frames, obj.States.x);
Sigma_I1L = subs(Sigma_I1L, obj.States.x(1:6), zeros(6,1));  

frames = {obj.OtherPoints.MultisenseAccelerometerFrame, joint_frames{:}, obj.ContactPoints.LeftToeBottom};
Sigma_I2L = Compute_FK_Covariance(frames, obj.States.x);
Sigma_I2L = subs(Sigma_I2L, obj.States.x(1:6), zeros(6,1));  

% Right Foot Contact Frame
joints = obj.Joints(14:end);
joint_frames = cell(1,length(joints));
for i = 1:length(joints)
    joint_frames{i} = CoordinateFrame(...
        'Name',joints(i).Name,...
        'Reference',joints(i),...
        'Offset',[0, 0, 0],...
        'R',[0, 0, 0]);
end

frames = {obj.OtherPoints.VectorNav, joint_frames{:}, obj.ContactPoints.RightToeBottom};
Sigma_I1R = Compute_FK_Covariance(frames, obj.States.x);
Sigma_I1R = subs(Sigma_I1R, obj.States.x(1:6), zeros(6,1));  

frames = {obj.OtherPoints.MultisenseAccelerometerFrame, joint_frames{:}, obj.ContactPoints.RightToeBottom};
Sigma_I2R = Compute_FK_Covariance(frames, obj.States.x);
Sigma_I2R = subs(Sigma_I2R, obj.States.x(1:6), zeros(6,1));  

% Export
N = length(frames)-1;
sigmas = SymVariable('sigma', [N-1,1]);
export_function(Sigma_I1L, 'Sigma_VectorNav_to_LeftToeBottom', export_path, {encoders, sigmas});
export_function(Sigma_I1R, 'Sigma_VectorNav_to_RightToeBottom', export_path, {encoders, sigmas});
export_function(Sigma_I2L, 'Sigma_MultisenseIMU_to_LeftToeBottom', export_path, {encoders, sigmas});
export_function(Sigma_I2R, 'Sigma_MultisenseIMU_to_RightToeBottom', export_path, {encoders, sigmas});

end


function [ Sigma, Q, S ] = Compute_FK_Covariance( frames, x )
% Computes covariance matrix for rotational/translational noise
%   
%   Author: Ross Hartley
%   Date:   11/14/2017
%   

N = length(frames)-1;
sigmas = SymVariable('sigma', [N-1,1]);

H1 = frames{1}.computeForwardKinematics;
HN1 = frames{N+1}.computeForwardKinematics;
A1 = H1(1:3,1:3);
AN1 = HN1(1:3,1:3);
A1N1 = A1'*AN1;

for i = 1:(N-1)
    Hi1 = frames{i+1}.computeForwardKinematics;
    sigma_i_dagger = frames{i+1}.Reference.Axis' * sigmas(i);
    A1i1 = A1'*Hi1(1:3,1:3); % Rotation from 1 to i+1
    AiN1 = A1i1'*A1N1;       % Rotation from i+1 to N+1 (Contact)
    
    for n = i:(N-1)
        Hn1 = frames{n+1}.computeForwardKinematics;
        Hn2 = frames{n+2}.computeForwardKinematics;
        Hn1n2 = Hn1\Hn2;
        tn1 = Hn1n2(1:3,end); 
        tn1 = subs(tn1, x, zeros(20,1)); % Should be a constant
        
        % Translation from n to n + 1
        A1n1 = A1'*Hn1(1:3,1:3); % Rotation from 1 to n+1
        Ai1n1 = A1i1'*A1n1;      % Rotation from i+1 to n+1
        % Compute Sum
        if n == i
            Si_sum = A1n1*Angles.skew(tn1)*Ai1n1';
        else
            Si_sum = Si_sum + A1n1*Angles.skew(tn1)*Ai1n1';
        end
    end

    % Build Covariance Matrix
    if i == 1
        Q = AiN1(1:3,1:3)';
        S = -Si_sum;
        sigma_dagger = sigma_i_dagger;
    else
        Q = [Q, AiN1(1:3,1:3)'];
        S = [S, -Si_sum];
        sigma_dagger = [sigma_dagger; sigma_i_dagger];
    end
end
Sigma = [Q; S] * diag(sigma_dagger) * [Q; S].';

end